import { Behaviour, Text, registerBinaryType, serializable } from "@needle-tools/engine";
import { SendBuffer_Model } from "./SendBuffer_Model";
import { Builder } from "flatbuffers";

// NOTICE: to utilize binary messages from a npmdef, you need to install the flatbuffers package @2.0.4 in your project

// needs to be 4 letters exactly, a specification of flatbuffers
const msgId = "MESG";

// Register the Model factory with the message ID, so a handler registered with beginListenBinary can intersct it
// The SendBuffer_Model is generated by flatbuffer CLI utility called flatc awailable on github (https://github.com/google/flatbuffers/releases)
// The Scheme is defined in the SendBuffer_Model.fbs file and the utility generates the SendBuffer_Model.ts file which we use below.
registerBinaryType(msgId, SendBuffer_Model.getRootAsSendBuffer_Model);

export class SendBufferExample extends Behaviour {
    @serializable(Text)
    msgLabel?: Text;

    @serializable(Text)
    saveStateLabel?: Text;

    @serializable()
    saveState: boolean = true;

    // we need to store the handler that we register so we can unregister it as well
    private handler?: any;

    onEnable() {
        this.handler ??= this.recieveBuffer.bind(this); //a callback needs to be binded to this instance
        this.context.connection.beginListenBinary(msgId, this.handler); 
    }

    onDisable() {
        this.context.connection.stopListenBinary(msgId, this.handler);
    }

    recieveBuffer(receivedModel: SendBuffer_Model) {
        if(this.msgLabel)
            this.msgLabel.text = receivedModel.message() || "";
    }

    sendBuffer() {        
        // With flatbuffers we need to create values first and then insert them into hiearchy.
        // So the order of the keywords you should call in flatbuffer workflow is: create, start, add, end, finish
        // In other words, first we add unique values and later we define the place they have in the hiearchy.

        // maintains a binary buffer that is later sent
        const builder = new Builder(0);

        // create values and save their poistions in the buffer
        const guidOffeset = builder.createString(this.guid);
        const dontSaveOffset = !this.saveState; // booleans don't need to be created
        const messageOffset = builder.createString(this.getExampleMessage());

        // Add the positions of the previously created values to fit the scheme's structure
        SendBuffer_Model.startSendBuffer_Model(builder);
        SendBuffer_Model.addGuid(builder, guidOffeset);
        SendBuffer_Model.addDontSave(builder, dontSaveOffset);
        SendBuffer_Model.addMessage(builder, messageOffset);
        const endPos = SendBuffer_Model.endSendBuffer_Model(builder);
        builder.finish(endPos, msgId); // add the MsgID to the flat buffer so it can be identified upon reciving

        // send
        const payload = builder.asUint8Array();
        this.context.connection.sendBinary(payload);
    }

    deleteState() {
        this.context.connection.sendDeleteRemoteState(this.guid); // delete all state for this component
    }

    awake() {
        this.updateSaveStateLabel();
    }

    getExampleMessage() { return `Hello, it is ${new Date(Date.now()).toLocaleTimeString()}!`; }

    toggleSaveState() {
        this.saveState = !this.saveState;
        this.updateSaveStateLabel();
    }

    updateSaveStateLabel() {
        if(this.saveStateLabel)
            this.saveStateLabel.text = `Save state: ${this.saveState}`;
    }
}